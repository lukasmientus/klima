<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Gassimulation mit Behälter</title>
  <style>
    canvas {
      background: #111;
      display: block;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>

<canvas id="gasCanvas" width="800" height="500"></canvas>

<script>
  const canvas = document.getElementById('gasCanvas');
  const ctx = canvas.getContext('2d');

  const particles = [];

  const pathPoints = [
    { x: 0, y: 200 },
    { x: 200, y: 160 },
    { x: 400, y: 240 },
    { x: 600, y: 180 },
    { x: 700, y: 200 }
  ];

  const container = {
    x: 700,
    y: 200,
    width: 80,
    height: 250
  };

  function getPathPosition(t) {
    const segment = Math.floor(t * (pathPoints.length - 1));
    const start = pathPoints[segment];
    const end = pathPoints[segment + 1] || pathPoints[pathPoints.length - 1];
    const localT = (t * (pathPoints.length - 1)) % 1;

    const x = start.x + (end.x - start.x) * localT;
    const y = start.y + (end.y - start.y) * localT;

    return { x, y };
  }

  class Particle {
    constructor() {
      this.reset();
    }

    reset() {
      this.inContainer = false;
      this.t = 0;
      this.speed = Math.random() * 0.003 + 0.001;
      this.radius = Math.random() * 3 + 1.5;
      this.opacity = Math.random() * 0.5 + 0.3;

      this.x = 0;
      this.y = 0;

      // Wenn im Behälter:
      this.vx = 0;
      this.vy = 0;
    }

    update() {
      if (!this.inContainer) {
        this.t += this.speed;
        if (this.t >= 1) {
          this.inContainer = true;
          this.x = container.x + container.width / 2;
          this.y = container.y + 5;

          // Zufällige Bewegung wie Gasatom
          const angle = Math.random() * 2 * Math.PI;
          const speed = Math.random() * 1.5 + 0.5;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
        } else {
          const pos = getPathPosition(this.t);
          this.x = pos.x;
          this.y = pos.y;
        }
      } else {
        this.x += this.vx;
        this.y += this.vy;

        // Wände des Behälters
        if (this.x - this.radius < container.x) {
          this.x = container.x + this.radius;
          this.vx *= -1;
        }
        if (this.x + this.radius > container.x + container.width) {
          this.x = container.x + container.width - this.radius;
          this.vx *= -1;
        }
        if (this.y - this.radius < container.y) {
          this.y = container.y + this.radius;
          this.vy *= -1;
        }
        if (this.y + this.radius > container.y + container.height) {
          this.y = container.y + container.height - this.radius;
          this.vy *= -1;
        }
      }
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(173,216,230,${this.opacity})`;
      ctx.fill();
    }
  }

  // Neue Partikel regelmäßig erzeugen
  setInterval(() => {
    if (particles.length < 300) {
      particles.push(new Particle());
    }
  }, 100);

  function drawPath() {
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
    for (let i = 1; i < pathPoints.length; i++) {
      ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
    }
    ctx.stroke();
  }

  function drawContainer() {
    ctx.fillStyle = '#333';
    ctx.fillRect(container.x, container.y, container.width, container.height);
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawPath();
    drawContainer();

    particles.forEach(p => {
      p.update();
      p.draw();
    });

    requestAnimationFrame(animate);
  }

  animate();
</script>

</body>
</html>
